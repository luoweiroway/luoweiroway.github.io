---
layout:     post
title:      "如何调用系统调用"
subtitle:   "linux"
categories: "内核与系统编程"
date:       2015-05-10
author:     "Roway"
header-img: "http://7xizd0.com1.z0.glb.clouddn.com/blog/universe.jpg"
tags: [linux kernel]
---

C标准库的很多IO函数都是要调用系统调用的，所以问题来了，怎么调用系统调用？

<!-- more -->


# 系统调用

每个函数的名称前缀都是`sys_`,该函数唯一标识为一个系统调用。

## 内核中的系统调用定义

比如getpid()这个系统调用在内核的实现:

```c
SYSCALL_DEFINE0(getpid)
{
	return task_tgid_vnr(current);
}
```

在内核中对应的是这样一个内核函数，这里使用了一个`SYSCALL_DEFINE0`，这是一个宏，0表示这是一个无参数的系统调用，同样还有`SYSCALL_DEFINE1`等表示含有一个参数，二个参数等的系统调用。

这个宏的实现如下:

```c
#define SYSCALL_DEFINE0(sname)					\
	SYSCALL_METADATA(_##sname, 0);				\
	asmlinkage long sys_##sname(void)
```

## 调用系统调用
有以下几种方法调用系统调用：

### 通过glibc封装的函数
linux系统上glibc库，已经帮我们封装了一些系统调用库函数，通过这些库函数可以直接调用系统调用。

### 调用syscall函数

>[syscall - indirect system call](http://man7.org/linux/man-pages/man2/syscall.2.html)

如果内核新增了系统调用，但是glibc库又没有进行封装，这个时候可以使用syscall函数(其实现可参见glibc的源码,`sysdeps/unix/sysv/linux/i386/syscall.S`及`sysdeps/unix/sysv/linux/x86_64/syscall.S`)来调用系统调用，加上系统调用号和参数就可以直接调用系统调用了。示例如下：

```c
#define _GNU_SOURCE        /* or _BSD_SOURCE or _SVID_SOURCE */
#include <unistd.h>
#include <stdio.h>
#include <sys/syscall.h>   /* For SYS_xxx definitions */
#include <sys/types.h>  
int main(int argc, char *argv[])
{
	pid_t tid;
    tid = syscall(SYS_getpid);
	printf("%d\n",tid);
	printf("%d\n",getpid());
	return 0;
}
```

两种调用输出结果是一样的。

syscall函数，其在/usr/include/unistd.h下定义，该头文件是glibc编译安装后装入系统的，其声明了syscall这个函数，如下：

```c
#ifdef __USE_MISC
/* Invoke `system call' number SYSNO, passing it the remaining arguments.
   This is completely system-dependent, and not often useful.
   In Unix, `syscall' sets `errno' for all errors and most calls return -1 for errors; in many systems you cannot pass arguments or get return values for all system calls (`pipe', `fork', and `getppid' typically among them).
   In Mach, all system calls take normal arguments and always return an error code (zero for success).  */
extern long int syscall (long int __sysno, ...) __THROW;

#endif  /* Use misc.  */
```

这里好奇一下，`__USE_MISC`是什么？另外上面示例程序中开头的`_GNU_SOURCE`又代表着什么？在`/usr/include/unistd.h`中的开头就include了`/usr/include/features.h`这个文件，我们进去看一下，基本上全是关于各种标准的的宏定义，首先看最前面的注释，如下所示：

```c
/* These are defined by the user (or the compiler)
   to specify the desired environment:

   __STRICT_ANSI__  ISO Standard C.
   _ISOC99_SOURCE   Extensions to ISO C89 from ISO C99.
   _POSIX_SOURCE    IEEE Std 1003.1.
   _POSIX_C_SOURCE  If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
            if >=199309L, add IEEE Std 1003.1b-1993;
            if >=199506L, add IEEE Std 1003.1c-1995;
            if >=200112L, all of IEEE 1003.1-2004
            if >=200809L, all of IEEE 1003.1-2008
   _XOPEN_SOURCE    Includes POSIX and XPG things.  Set to 500 if
            Single Unix conformance is wanted, to 600 for the
            sixth revision, to 700 for the seventh revision.
   _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
   _LARGEFILE_SOURCE    Some more functions for correct standard I/O.
   _LARGEFILE64_SOURCE  Additional functionality from LFS for large files.
   _FILE_OFFSET_BITS=N  Select default filesystem interface.
   _BSD_SOURCE      ISO C, POSIX, and 4.3BSD things.
   _SVID_SOURCE     ISO C, POSIX, and SVID things.
   _ATFILE_SOURCE   Additional *at interfaces.
   _GNU_SOURCE      All of the above, plus GNU extensions.
   _REENTRANT       Select additionally reentrant object.
   _THREAD_SAFE     Same as _REENTRANT, often used by other systems.
   _FORTIFY_SOURCE  If set to numeric value > 0 additional security
            measures are defined, according to level.

   The `-ansi' switch to the GNU C compiler defines __STRICT_ANSI__.
   If none of these are defined, the default is to have _SVID_SOURCE,
   _BSD_SOURCE, and _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
   200112L.  If more than one of these are defined, they accumulate.
   For example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE
   together give you ISO C, 1003.1, and 1003.2, but nothing else.

   These are defined by this file and are used by the
   header files to decide what to declare or define:

   __USE_ISOC99     Define ISO C99 things.
   __USE_ISOC95     Define ISO C90 AMD1 (C95) things.
   __USE_POSIX      Define IEEE Std 1003.1 things.
   __USE_POSIX2     Define IEEE Std 1003.2 things.
   __USE_POSIX199309    Define IEEE Std 1003.1, and .1b things.
   __USE_POSIX199506    Define IEEE Std 1003.1, .1b, .1c and .1i things.
   __USE_XOPEN      Define XPG things.
   __USE_XOPEN_EXTENDED Define X/Open Unix things.
   __USE_UNIX98     Define Single Unix V2 things.
   __USE_XOPEN2K        Define XPG6 things.
   __USE_XOPEN2KXSI     Define XPG6 XSI things.
   __USE_XOPEN2K8XSI    Define XPG7 XSI things.
   __USE_LARGEFILE  Define correct standard I/O things.
   __USE_LARGEFILE64    Define LFS things with separate names.
   __USE_FILE_OFFSET64  Define 64bit interface as default.
   __USE_BSD        Define 4.3BSD things.
   __USE_SVID       Define SVID things.
   __USE_MISC       Define things common to BSD and System V Unix.
   __USE_ATFILE     Define *at interfaces and AT_* constants for them.
   __USE_GNU        Define GNU extensions.
   __USE_REENTRANT  Define reentrant/thread-safe *_r functions.
   __USE_FORTIFY_LEVEL  Additional security measures used, according to level.
   __FAVOR_BSD      Favor 4.3BSD things in cases of conflict.

   The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
   defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
   only for compatibility.  All new code should use the other symbols
   to test for features.

   All macros listed above as possibly being defined by this file are
   explicitly undefined if they are not explicitly defined.
   Feature-test macros that are not defined by the user or compiler
   but are implied by the other feature-test macros defined (or by the
   lack of any definitions) are defined by the file.  */
```

得知，该文件通过判断用户定义了哪些宏，然后主动定义相应的宏。如果定义了`_GNU_SOURCE`，则所有的标准都会被定义,如果什么都没定义，那么`_BSD_SOURCE`和`_SVID_SOURCE`会默认被定义。这里牵扯到UNIX的标准及各种实现分支的关系。

比如如果你定义了`_BSD_SOURCE`那么`__USE_BSD`就会定义，`_SVID_SOURCE`定义了则`__USE_SVID`会定义，前面两个只要有一个定义了，那么`__USE_MISC`会被定义。

实现如下：

```c
/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */
#ifdef _GNU_SOURCE                                 
# undef  _ISOC95_SOURCE
# define _ISOC95_SOURCE 1
# undef  _ISOC99_SOURCE
# define _ISOC99_SOURCE 1
# undef  _POSIX_SOURCE
# define _POSIX_SOURCE  1
# undef  _POSIX_C_SOURCE
# define _POSIX_C_SOURCE    200809L
# undef  _XOPEN_SOURCE
# define _XOPEN_SOURCE  700
# undef  _XOPEN_SOURCE_EXTENDED
# define _XOPEN_SOURCE_EXTENDED 1
# undef  _LARGEFILE64_SOURCE
# define _LARGEFILE64_SOURCE    1
# undef  _BSD_SOURCE
# define _BSD_SOURCE    1
# undef  _SVID_SOURCE
# define _SVID_SOURCE   1
# undef  _ATFILE_SOURCE
# define _ATFILE_SOURCE 1
#endif

/* If nothing (other than _GNU_SOURCE) is defined,
   define _BSD_SOURCE and _SVID_SOURCE.  */
#if (!defined __STRICT_ANSI__ && !defined _ISOC99_SOURCE && \
     !defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE && \
     !defined _XOPEN_SOURCE && !defined _BSD_SOURCE && !defined _SVID_SOURCE)
# define _BSD_SOURCE    1
# define _SVID_SOURCE   1
#endif

#if defined _BSD_SOURCE || defined _SVID_SOURCE
# define __USE_MISC 1
#endif

#ifdef  _BSD_SOURCE
# define __USE_BSD  1
#endif

#ifdef  _SVID_SOURCE
# define __USE_SVID 1
#endif
```

既然挖到这一步了，何不再挖一步？

上面示例程序中我们include了`/usr/include/sys/syscall.h`这个头文件，在外面一层目录还有`/usr/include/syscall.h`这个文件，不过这个文件的内容就是包含`/usr/include/sys/syscall.h`，`/usr/include/sys/ssyscall.h`头文件的内容如下：

```c
#ifndef _SYSCALL_H
#define _SYSCALL_H  1
/* This file should list the numbers of the system the system knows.
   But instead of duplicating this we use the information available
   from the kernel sources.  */
#include <asm/unistd.h>

#ifndef _LIBC
/* The Linux kernel header file defines macros `__NR_<name>', but some programs expect the traditional form `SYS_<name>'.  So in building libc we scan the kernel's list and produce <bits/syscall.h> with macros for all the `SYS_' names.  */
#include <bits/syscall.h>
#endif
```

其中`/usr/include/bits/syscall.h`文件是glibc编译过程中扫描内核系统调用列表后生成的，其将`SYS_<name>`宏转换成内核头文件使用的`__NR_<name>`宏，用户程序中不要直接include该文件，而应该include`/usr/include/sys/syscall.h`。

而`/usr/include/asm/unistd.h`则是定义了所有的系统调用号，该文件的内容很少，就是分别include `/usr/include/asm/unistd_32.h`和`/usr/include/asm/unistd_64.h`两种文件，前者定义的以i386为代表的x86-32体系结构下linux的系统调用号，而后者则定义的是x86-64体系结构下linux的系统调用号，注意两种系统调用号系统是不一致的。

### 直接汇编调用

这是最原始的方法，上面的syscall函数即代替我们做了这样的事，其实现中会依据情况去调用下面说的三种指令：int $0x80、sysenter和syscall。这篇[linux下系统调用的实现](http://www.pagefault.info/?p=99)详细讲解了这一部分内容。基本的x86体系下系统调用相关的指令可以看[阅读笔记：x86系统调用入门](http://blog.csdn.net/yayong/article/details/416477).

以gcc为例，在C语言中插入汇编，需要了解gcc inline asm的相关使用语法。
其一般语法为：

```c
__asm__ __volatile__ ("asm statements" : output : input : modify);
```

>[GCC Inline ASM ](http://wenku.baidu.com/view/af62b70d581b6bd97f19ea88.html)
>[2.6.3 Gcc嵌入式汇编](http://oss.org.cn/kernel-book/ch02/2.6.3.htm)

当然，还得了解系统调用的过程，到底发生了什么，这里暂不叙述。可参考：

>[Linux系统调用过程研究](http://blog.csdn.net/luomoweilan/article/details/6536152)
>[探究 SCI 并添加自己的调用](http://www.ibm.com/developerworks/cn/linux/l-system-calls/)、[Explore the SCI and add your own calls](http://www.ibm.com/developerworks/library/l-system-calls/)
>[Linux系统调用](http://blog.csdn.net/longerzone/article/details/12493633)

#### int指令

这是老版本linux内核中引起系统调用的唯一方式，用户态程序通过软中断指令`int 0x80`来陷入内核态，这是一个多路汇聚以及分解的过程，该汇聚点就是0x80中断这个入口点（X86系统结构），所有系统调用都从用户空间中汇聚到0x80中断点，当0x80中断处理程序(system_call函数，这个函数和硬件体系结构密切相关，在x86-64系统中是在`entry_64.S`文件中定义的)运行时，将根据系统调用号调用不同的内核函数处理。参数的传递是通过寄存器，eax传递的是系统调用号，ebx、ecx、edx、esi和edi来依次传递最多五个参数，当系统调用返回时，返回值存放在 eax 中。
示例程序：

```c
#define _GNU_SOURCE        /* or _BSD_SOURCE or _SVID_SOURCE */
#include <unistd.h>
#include <stdio.h>
#include <sys/syscall.h>   /* For SYS_xxx definitions */
#include <sys/types.h>  
int main(int argc, char *argv[])
{
	pid_t tid;
    //tid = syscall(SYS_getpid);
    __asm__ volatile ("int $0x80":"=a"(tid):"a"(SYS_getpid));
	printf("%d\n",tid);
	printf("%d\n",getpid());
	return 0;
}
```

getpid这个系统调用由于没有参数，所以该内联汇编会比较简单，稍复杂的可以参考相关语法。

需要编译生成32位可执行文件，这在64位系统下可能需要额外再安装32位的GNU C Library及libx32gcc开发包，比如在Ubuntu下可以输入`apt-get install libc6-dev-i386`来安装，其会依赖安装相关包。

#### sysenter指令

Intel Pentium II中引入了sysenter指令，比int指令更快，更专业的陷入内核执行系统调用。

#### syscall指令

将上面的示例程序修改一下，如下所示：

```c
#define _GNU_SOURCE        /* or _BSD_SOURCE or _SVID_SOURCE */
#include <unistd.h>
#include <stdio.h>
#include <sys/syscall.h>   /* For SYS_xxx definitions */
#include <sys/types.h>  
int main(int argc, char *argv[])
{
	pid_t tid;
    //tid = syscall(SYS_getpid);
    __asm__ volatile ("syscall":"=a"(tid):"a"(SYS_getpid));
	printf("%d\n",tid);
	printf("%d\n",getpid());
	return 0;
}
```






