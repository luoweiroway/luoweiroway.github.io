---
layout:     post
title:      "彻底理解内存寻址(一)"
subtitle:   "X86概览"
categories: "计算机底层"
date:       2014-12-01
author:     "Roway"
header-img: "http://7xizd0.com1.z0.glb.clouddn.com/blog/cpu.jpg"
tags: [X86内存寻址]
---


X86是一种比较特殊的处理器体系架构，也是现今计算机最常见的处理器架构。

<!-- more -->

# 1 内存模型

## 1.1 flat memory model
> [wiki/Flat_memory_model](https://en.wikipedia.org/wiki/Flat_memory_model)

即linear memory model，这种存储器定址方式(memory addressing paradigm)下，应用程序看到的内存是一个单独的连续地址空间，CPU可以直接（且线性）地寻址所有可利用的内存位置，无需借助任何内存分段(memory segmentation)或分页机制(paging schemes)。

## 1.2 Paged memory model

## 1.3 X86 Segmented memory model


# 2 x86 memory segmentation

> [wiki/Memory_segmentation](https://en.wikipedia.org/wiki/Memory_segmentation)
> [wiki/X86_memory_segmentation](https://en.wikipedia.org/wiki/X86_memory_segmentation),[中文页面](https://zh.wikipedia.org/wiki/X86%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5)

x86 memory segmentation是X86指令集架构下`内存分段(memory segmentation)`的实现。

* 1978年Intel 8086中首次引入分段(segmentation)，这使得16位CPU可以访问超过64 KB (2^16，65,536字节)的内存，8086处理器与内存芯片间的地址总线是20位，即可访问2^20=1MB内存。

* 1982年，Intel 80286则引入了另一种分段，其支持内存保护，并将8086的模式命名为`real mode`，新的模式则叫做`protected mode`。
 * 从8086开始到随后的各款x86架构CPU，无论是实模式还是保护模式，内存寻址时**都使用16位段寄存器**（segment register)，但**两种模式下对段寄存器的使用是不一样的**。
 * 处理器启动时处于real mode，即使用8086的分段寻址模式。

* 1985年Intel 80386以及之后的X86架构CPU的**protected mode都保持了80286 protected mode下的分段机制**。增加了`virtual 8086 mode`，也叫virtual real mode, V86-mode，当处理器运行在protected mode的操作系统下，可以直接运行real mode的程序，这是一种硬件虚拟化技术。
 * 80386在segmentation unit和physical bus之间加入了paging unit，作为第二级的地址翻译，集成了MMU来完成这一功能。
 * 除了CS, DS, ES和SS，增加了两个段寄存器FS和GS，这两个寄存器并无硬件绑定的用途；另外与80286不同的是，80386只需要将CRO控制寄存器的某个位清零就可以进入real mode。

* 2003年的x86-64架构在`long mode(64-bit mode)`下不再使用分段(segmentation)。四个段寄存器CS, SS, DS, ES强制为0，段长度强制为2^64。段寄存器FS、GS可以有非0值，被操作系统用于其它用途。上电后，CPU处于real mode且与32-bit Pentium IV几乎一样，只有在long mode开启后64-bit指令才可以运行，而且CPU必须先进入32-bit protected mode然后才能进long mode。当处于long mode时，16-bit的指令以及virtual x86 mode无效，protected mode也不再工作。

段的选择通常由处理器根据正在被执行的指令默认指定。指令总是从code segment里面获取，对任何栈的push或pop操作以及栈中的数据引用都是使用stack segment，其他数据的引用使用data segment，extra segment默认用来string operation(如MOVS、CMPS)，FS和GS并没有硬件绑定的用途。处理器指令中可以明示使用哪些段寄存器，这将替换掉默认使用的段寄存器。

![](http://7xizd0.com1.z0.glb.clouddn.com/blog/80x86.jpg)

# 3 X86各模式

## 3.1 实模式(real mode)

实模式与虚拟86模式下，一个段总是长64,536字节（16位段内偏移地址）。在段寄存器内的16-bit被解释为**20位线性地址**空间的高16位，称为段地址；其余的低4位全为0。段地址与16位段内偏移地址相加产生线性地址，同时也是这种内存模式下的物理地址.任何程序都可以访问全部内存空间。没有对内存的访问权限保护。

这是Intel分段设计的根源，寄存器和数据总线位宽为16位，而地址位宽却是20位，16位的数据位宽只能表示64KB内存，而20位的地址位宽可实际寻址1MB。于是引入了段寄存器（segment register），用来告诉CPU一条程序指令将操作哪一个64K的内存区块。先加载段寄存器，相当于表明打算操作开始于X处的内存区块，之后再用16位的内存地址来表示相对于那个内存区块（或段）的偏移量。总共有4个段寄存器：一个用于栈（ss），一个用于程序代码（cs），两个用于数据（ds，es）。在那个年代，大部分程序的栈、代码、数据都可以塞进对应的段中，每段 64KB 长，分段功能经常是透明的。

之后，分段功能就一直存在了。

**当CPU执行指令需要访问内存时，只会送出段内的偏移地址，而通过指令的类型类确定访问哪一个段寄存器。**

![](http://7xizd0.com1.z0.glb.clouddn.com/blog/x86-segmentation-in-16bit-real-mode.jpg)

实模式的段地址以16个字节为步长，从0开始编号一直到 0xFFFF0 （即 1MB ）。你可以将一个从0到0xFFFF的16位偏移量（逻辑地址）加在段地址上。在这个规则下，对于同一个内存地址，会有多个段地址/偏移量的组合与之对应，而且物理地址可以超过1MB的边界，只要你的段地址足够高（参见臭名昭著的A20线）。在实模式的C语言代码中，一个远指针（far pointer）既包含了段选择符又包含了逻辑地址，用于寻址1MB的内存范围。

随着程序变得越来越大，超出了64K的段，分段功能以及它古怪的处理方式，使得x86平台的软件开发变得非常复杂。Intel又引入了新的分段机制，仍然使用16位的段寄存器，但其表示的意义不再一样。

## 3.2 80286保护模式

Intel 80286处理器引入的保护模式是另一种分段机制，**仍然使用16位段寄存器与16位的段内偏移地址**，但支持访问2^24（16M）字节的内存。**16位段寄存器内不再是段地址**，其高13位被称作段选择符（segment selector），值是到段描述符表(segment descriptor中)的索引值。段描述符中包含了**24位的segment base**，20位的段长度。段开始地址与段内偏移地址相加为线性地址，并作为内存物理地址。段的长度上限为2^20=1M字节。

## 3.3 80386保护模式

Intel 80386处理器**继续使用80286的分段保护模式**，仍然使用16位段寄存器，但**段内偏移地址和段描述符中的segment base为32位**。

在分段转址与物理地址之间又增加了一层分页（paging）转址。**分段寻址是不能关闭的,分页可以使能或关闭，如果关闭就与80286保护模式一样。**如果使用分页机制，则由段开始基地址与段内偏移地址相加得到的是线性地址（虚地址），线性地址还需要由paging unit翻译成物理地址。80386下的物理地址是32-bit，但是在之后支持PAE的处理器下可以超过32-bit。

这里，我们可以发现，由于段基址和偏移地址都是32位的，所以不管怎样，寄存器和指令都可以寻址整个线性地址空间，所以根本就不需要再去使用基地址。完全可以将基地址设成0，让逻辑地址与线性地址一致呢。Intel的文档将之称为“扁平模型”（flat model），而且在现代的x86系统内核中就是这么做的（特别指出，它们使用的是基本扁平模型）。基本扁平模型（basic flat model）等价于在转换地址时关闭了分段功能，注意是等价于，并不是真的关闭，因为也关闭不了。

可以看到，Intel巧妙的绕过了他们原先设计的那个拼拼凑凑的分段方法，而是提供了一种富于弹性的方式来让我们选择是使用段还是使用扁平模型。由于很容易将逻辑地址与线性地址合二为一，于是这成为了标准，比如现在在 64 位模式中就强制使用扁平的线性地址空间了。但是即使是在扁平模型中，段对于x86的保护机制也十分重要。保护机制用于抵御用户模式进程对系统内核的非法内存访问，或各个进程之间的非法内存访问，详见下一篇文章。

# 4 地址

* 物理地址
在支持Intel的主板芯片组上，CPU对内存的访问是通过连接着CPU和北桥芯片的前端总线来完成的。在**前端总线上传输的内存地址都是物理内存地址** ，编号从0开始一直到可用物理内存的最高端。这些数字被北桥映射到实际的内存条上。**物理地址是明确的、最终用在总线上的编号**，不必转换，不必分页，也没有特权级检查。

* 逻辑地址
在 CPU 内部，程序所使用的是逻辑内存地址，它必须被转换成物理地址后，才能用于实际内存访问。逻辑地址指的是机器语言指令中，用来指定一个操作数或者是一条指令的地址。
Intel为了兼容，将远古时代的段式内存管理方式保留了下来。Intel段式管理中，对逻辑地址要求，“一个逻辑地址，是由一个段标识符加上一个指定段内相对地址的偏移量，表示为 [段标识符：段内偏移量]”。

* 线性地址
跟逻辑地址类似，它也是一个不真实的地址，如果逻辑地址是对应的硬件平台段式管理转换前地址的话，那么线性地址则对应了硬件页式内存的转换前地址。
* 虚拟地址
分页机制下的线性地址。

![](http://7xizd0.com1.z0.glb.clouddn.com/blog/X86-memory-address-translation.jpg)

上图描述了在CPU的分页功能开启的情况下内存地址的转换过程。如果CPU关闭了分页功能，或运行于16位实模式，那么从分段单元（segmentation unit ）输出的就是最终的物理地址了。当CPU要执行一条引用了内存地址的指令时，转换过程就开始了。

CPU地址转换需要进行两步：首先给定一个逻辑地址（即段内偏移量），CPU要利用其段式内存管理单元，先将每个逻辑地址转换成一个线性地址，再利用其页式内存管理单元，转换为最终物理地址。

这样做两次转换，的确是非常麻烦而且没有必要的，前面已经提过一次了，因为直接可以把线性地址抽象给进程。之所以这样冗余，Intel完全是为了兼容而已，见8086设计。硬件要求这样做了，软件就只能照办。而Linux的段式管理，事实上只是“哄骗”了一下硬件而已。




# 参考
[为什么x86上Linux kernel没有自己独立的地址空间？](http://blog.sina.com.cn/s/blog_6488248f0100x7r3.html)
[linux内存管理---虚拟地址、逻辑地址、线性地址、物理地址的区别（一）](http://blog.csdn.net/yusiguyuan/article/details/9664887)
[我理解的逻辑地址、线性地址、物理地址和虚拟地址](http://bbs.chinaunix.net/thread-2083672-1-1.html)
[计算机原理学习（7）-- x86-32 CPU和内存管理之分段管理](http://blog.csdn.net/cc_net/article/details/24726287)
http://www.kerneltravel.net/books/ulk_ch02.pdf