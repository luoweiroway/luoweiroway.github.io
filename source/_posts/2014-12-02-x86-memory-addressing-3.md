---
layout:     post
title:      "彻底理解内存寻址(三)"
subtitle:   "X86分页机制"
categories: "计算机底层"
date:       2014-12-02
author:     "Roway"
header-img: "http://7xizd0.com1.z0.glb.clouddn.com/blog/cpu.jpg"
tags: [X86内存寻址]
---

x86的段机制把程序的逻辑地址转换成线性地址，这里要讲的分页机制是把线性地址映射成物理地址

<!-- more -->

## 1 为什么引入分页

16位CPU的内存访问技术所存在的缺点：

* 单任务： 16位的CPU只支持单任务，也就是同时只有一个程序在运行，随着计算机的发展，单任务的缺点在于体验较差；
* 内存小： 前面我们知道，在运行程序时，会把程序全部加载到内存中，但是当程序大于内存时，程序就无法运行了；
* 地址不确定：每次程序装载时分配的地址可能都不一样，使得程序在编写时处理转跳等问题非常麻烦。
* 安全差： 因为对于内存访问没有太多的限制，所以应用程序很容易去修改操作系统以及BIOS和硬件映射的内存空间，导致系统崩溃；

而当80386引入多任务的支持后，以前的内存管理方式已经不能满足现状的需求的了。于是我们需要新的内存管理方式来解决上面的问题：

* 地址空间：这个是对物理内存的一个抽象，就好像进程是对CPU的一个抽象。一个进程可用于寻址的一套地址的集合，每个进程都有自己的地址空间，相互独立，这就解决了安全问题。
* 交换：把程序全部加载到内存，当进程处于空闲时，把他移除内存，存放到硬盘上，然后载入其他程序。这样使得每个进程可以使用更多的内存。
* 虚拟内存：在老的内存管理中，一次把程序加载到内存，而当程序过大时就无法正常运行了。而利用到计算机系统的局部性和存储分层，我们可以只加载一部分需要使用的代码和数据到内存，当访问的内容不在内存时，和已经使用完的部分进行交换，这样就能在小内存的机器上运行大的程序了。对于程序来说这是透明的，看起来自己好像使用了全部内存。而多个应用完全可以使用相同的虚拟地址。

分段和分页本质不同，16位的分段访问是为了解决地址线位数大于CPU位数的问题。而虚拟寻址则是真正解决了上面提到的那些问题。当然，Intel为了兼容，仍旧支持16位的分段式内存访问。

# 2 相关软硬件概念

* 实现分页机制的硬件结构有：
 * 四个专用于分页机制的32位寄存器：CR0、CR1、CR2、CR3；
 * 分页部件；
 * 页面高速缓存；
* 软件结构有：
 * 页
 * 页表
 * 页目录
 * 页表项。

## 分页专用寄存器

CR0中包含了6个预定义标志，这里只介绍内核中用到的0位和31位。第0位是保护允许位， 为1时启动保护模式。31位用于分页允许，为1时表示开启分页机制，为0时表示不用分页机制，这时只用段机制实现地址映射。。

CR1暂时没用。

CR2是缺页线性地址寄存器，当发生缺页异常的时候，该寄存器保存最后一次出现缺页的全32位线性地址，这在异常处理时会介绍到，这里我们不深究它的实现过程。

CR3叫做页目录基址寄存器，顾名思义，它保存的是页目录的物理地址。我们就是通过该寄存器里边的值，找到对应的页目录中的页表项，从而知道我们的一个页是存储里内存中的哪个位置的。

## 2.1 页

分页机制的思想是将线性地址空间划分成若干相等的片，这一片就称为一个页，并从0开始给各页编号。相应的，我们也把物理地址空间划分成与页大小相等的若干存储块，也同样为他们编号，仍然从0开始。

这样就有一个问题了，因为页是固定大小的，那么它过大或者过小都会影响内存使用率。页过大，有时候会存在冗余空间；页过小，若有分支指令，则会存在在页之间跳转的情况，同样影响效率。x86支持的标准页大小为4KB（也支持4MB）。

## 2.2 页表

页表是把线性地址转换成物理地址的一种数据结构。有点类似于段描述符表的作用。它包括两个成员：

* 物理页面基地址：线性地址空间中的一个页装入内存后所对应的物理页面的起始地址。
* 页的属性：描述一些页的属性信息。

页面大小为4KB，即一个页面会占4KB的空间，那么每个页面的物理页面基地址必然是4KB的整数倍，也就是说其地址的最低12位总是0，那么我们就可以用这12位存放页的属性，这样用32位的地址就完全可以描述页的映射关系，也就是页表中一个表项占四个字节就够了。

不过，4GB的线性地址空间可以被划分为1M个4KB大小的页，每个页表项占4个字节，则1M个页表项就需要占4MB的空间，而且还要求是连续的，这显然是不现实的，于是把这4MB的页表再以4KB为大小分页，分为1K个页，同样对每个项描述需要四个字节，这就是两级页表的管理方式。

### 2.2.1 两级页表

两级页表的第一级把它叫做页目录，用它来管理1M个页的页表。上边说我们把1M个页表项以4KB为页分了1K个页，于是我们用10位就可以检索到这1K个页目录的每个目录项了。现在我们把这1K个页目录（占4KB）放进内存的某个位置，这个位置就叫做页目录起始地址。我们把这个起始地址放进CR3中，现在来一个线性地址，我们根据线性地址的前10位，再根据CR3中的页目录起始地址，就可以得到目录项在内存中的地址。那我们读取这个目录项，其高20位就是页表在内存中的起始地址。于是我们用线性地址的中间10位和这个页表起始地址就可以计算出页表项的位置，这个页表项和线性地址的的低12位就可以把这个线性地址定位到内存中具体的位置了。

## 页面高速缓存

由于在分页情况下，页表是放在内存中的，这使CPU每次至少两次去访问内存。页面高速缓冲器保存最近处理过的32项页表项。当访问线性地址空间的某个地址时，先检查对应的页表项是否在缓存中，如果在就没必要两次访问内存了。高速缓存的命中率是相当高的。

# 3 页地址转换



# 4 段页式地址转换

**分段内存管理的优势在于内存共享和安全控制，而分页内存管理的优势在于提高内存利用率。**他们之间并不是相互对立的竞争关系，而是可以相互补充的。也就是可以把2种方式结合起来，也就是目前计算机中最普遍采用的段页式内存管理。**段页式管理的核心就是对内存进行分段，对每个段进行分页。**这样在拥有了分段的优势的同时，可以更加合理的使用内存的物理页。

![](http://7xizd0.com1.z0.glb.clouddn.com/blog/segment-page-address-1.jpg)

![](http://7xizd0.com1.z0.glb.clouddn.com/blog/segment-page-address-2.jpg)

上面的图简单的描述了在段页式内存管理的系统中地址转换的过程。

* CPU给出要访问的逻辑地址；
* 通过分段内存管理的地址转换机制，将逻辑地址转换为线性地址，也就是分页系统中的虚拟地址；
* 通过分页内存管理的地址转换机制，将虚拟地址转换为物理地址；

目前主流的系统中都采用了段页相结合的内存管理方式，当然不同的系统具体实现起来是不同的。**Linux操作系统在386保护模式下把段基址设为0，段长度设为4GiB，从而模拟了平面内存模型。**所有段首地址都是0x00000000，所以**逻辑地址和转换得到的线性地址是一致的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。**。

《现代操作系统》3.7章节关于分页与分段的比较:

![](http://7xizd0.com1.z0.glb.clouddn.com/blog/segment-vs-page.jpg)



# 待参考
http://blog.csdn.net/yusiguyuan/article/details/12746251
http://ccq.qijuwang.cn/n/t/b_3.html
http://www.cs.virginia.edu/~cs333/notes/virtualmemory.pdf
http://www.360doc.com/content/12/0920/15/7982302_237218174.shtml
http://www.motherboardpoint.com/threads/l1-l2-caches-and-mmu.152345/
http://www.aliog.com/3979.html
http://wiki.0xffffff.org/posts/hurlex-9.html
http://www.adintr.com/article/blog/298
http://www.cnblogs.com/xkfz007/archive/2012/10/08/2715163.html
http://blog.csdn.net/drshenlei/article/details/4582197
非常棒的一组文章http://blog.csdn.net/drshenlei/article/category/551407