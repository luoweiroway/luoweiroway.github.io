---
layout:     post
title:      "从为什么计算机要用补码来表示数值谈开去"
subtitle:   "打破沙锅"
categories: "root explanation"
date:       2014-11-18
author:     "Roway"
header-img: "http://7xizd0.com1.z0.glb.clouddn.com/blog/matrix_binary_code.jpg"
tags: [计算机系统]
---

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。

<!-- more -->

正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。

正数的补码就是其本身，负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)。

这些是很多人为了应付考试而背诵的，但是，背后的原因，还是应该去探究探究的！


# 机器数和真值
     
真值就是我们真实世界里的数字表示方法，正数1就表示为1（严谨点为：+1），负数1就表示为-1。但是计算机不能这么认为，对，computer is stupid！计算机内部得有个约定来表示数值，尤其是符号位。所以，这就涉及到了编码，“编”这个字就表明这是人为规定的，换句话说就是机器数是我们对数编码之后的二进制表示形式。
    
所以，问题来了！ 我们该采用什么样的编码规则？而且很明显我们想达到这样的目的：在此编码下，机器数经过加法器运算得到的机器数，其在我们的编码规则下正好是我们真实世界里的数值运算结果。而补码这一编码规则来表示有符号数，可以使加法器的设计异常简单。
     
一句话点名补码背后的数学原理就是取模运算[注1]，加上加法器的会让溢出的位丢弃，这样就使得补码可以满足上述要求。
     
用现实生活中来解释这个最好的例子是钟表，用十二小时制来想象一个钟表，假设现在是二点钟，我要到一点钟，很自然我可以往后拨1格，2-1=1，我也可以往前拨13格，2+11=13，但是因为中间过了个12,就要变为1，也就是说钟表会把12丢掉（这不就是十二进制的加法运算，最高位溢出，然后将溢出位丢弃，因为13表示不出来啊！！！而十二进制丢弃一位不就是丢弃十进制的12嘛，），也就是说2+11在钟表的法则下等于1，也就是说，这里，`2与-1相加`和`2与11相加`结果都是1。在钟表法则（只有1位数的十二进制数）下，-1等于11啊！！！
     
到这里，我们知道计算机里面所能表示的数值范围是有限的，加法器会把超出CPU字长的位丢弃（比如32位的CPU，运算时会把溢出的第33位丢弃），所以，我们应该想到，要想达到有符号数的正确运算效果，我们必须像钟表那样，采取某种编码方式，让“-1等于11“。


也就是说，补码编码方式得满足：（为讨论方便，我们假设CPU字长为8）
     
0000 0001+codeone=0（因为(+1)+(-1)=0），0000 0001为+1的补码，codeone为-1的补码；
     
因为超过八位的位机器会将其会溢出丢弃，所以很明显想到codeone为1111 1111，因为其加0000 0001后结果为1 0000 0000，但8位计算机只能表示8位，所以在计算机看来结果就是0了。
所以，-1的补码就是11111111。

让我们用书上写的那条规则再来算一下，”负数的补码是原码基础上，符号位不变，其余位取反，然后加1（即反码基础上加1）“：

>-1的原码为1000 0001  （可以看出原码是最符合人类思维，最高位为符号位，其余位为绝对值，一眼知其真实数值，可惜它不能用于电脑运算）
>-1的反码为1111 1110  （反码就不太友好了，你不能一眼看出其真实数值，它也不能用于电脑运算）
>-1的补码为1111 1111  （所以，补码虽然对人类不友好，但它对计算机友好啊！）
与上述一致！

| Bits | 无符号数 | 补码  |
| --------- |-----:| -----:|	
|0111 1111|	127| 	127|
|0111 1110|	126|	126|
|0000 0010|	2|	2|
|0000 0001|	1|	1|
|0000 0000|	0|	0|
|1111 1111|	255|	−1|
|1111 1110|	254|	−2|
|1000 0010|	130|	−126|
|1000 0001|	129|	−127|
|1000 0000|	128|	−128|

---------------

**Appendix 1**
在理解了上面的文字之后，要看详细内容，可以参考下面的这个[博文(猛戳)](http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)，此文写的很详细且清晰易懂！


**Appendix 2**
看完了上面这个博客，我觉得还有必要理解一下英文术语以及港台朋友们对此的术语：
[**Signed number representations**,点击查看](http://en.wikipedia.org/wiki/Signed_number_representations)
有符号数表示，[中文链接](http://zh.wikipedia.org/wiki/%E6%9C%89%E7%AC%A6%E8%99%9F%E6%95%B8%E8%99%95%E7%90%86)

[**one's complement**,点击查看](http://en.wikipedia.org/wiki/Ones'_complement) 
大陆翻译作反码，港台称作一补数，看得出来港台原汁原味啊，中文wiki上”补码“被重定向至”一补数“,[中文链接](http://zh.wikipedia.org/wiki/%E4%B8%80%E8%A3%9C%E6%95%B8)

[**two's complement**,点击查看](http://en.wikipedia.org/wiki/Two's_complement)
大陆翻译作补码，港台称作二补数,[中文链接](http://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8)


[注1]取模运算和取余运算是不一样的。各个环境下%运算符的含义不同，比如c/c++，java 为取余，而python则为取模。[详情戳此](http://baike.baidu.com/view/4887065.htm)



