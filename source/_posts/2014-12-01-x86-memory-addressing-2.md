---
layout:     post
title:      "彻底理解内存寻址(二)"
subtitle:   "X86分段机制"
categories: "计算机底层"
date:       2014-12-01
author:     "Roway"
header-img: "http://7xizd0.com1.z0.glb.clouddn.com/blog/cpu.jpg"
tags: [X86内存寻址]
---

x86的分段机制是实现程序的逻辑地址到线性地址的映射的一种机制。

<!-- more -->

本文以80386保护模式为主。

# 1 一些概念

* 硬件：16位的段寄存器、分段部件、段描述符高速缓冲器；
* 软件(数据结构)：段描述符表、段描述符；
* 两个概念：逻辑地址和线性地址。上一篇文章已提到。

## 1.1 段寄存器

### 1.1.1 8086实模式

前面一篇文章已经提到，这里就不说了，以80286/80386为主。

### 1.1.2 80386保护模式

逻辑地址是`16位的段选择符:32位偏移地址`，段寄存器不再保存段基址，取而代之的是一个索引编号，用于引用段描述符表中的表项。这个表为一个简单的数组，元素长度为8字节，每个元素描述一个段。

80286和80386的分段机制中，段寄存器存放的就是段描述符在段描述符表中的索引，严格来说是前13位存储段描述符的索引，然后第2位(TI)表示是从全局描述符表(GDT)中选择段描述符还是从局部描述符表（LDT）中选择段描述符。剩下两位表示请求者的特权级。

之所以叫保护模式，就是因为保护模式提供了CPU的不同运行特权，ss（堆栈段寄存器）和ds（数据段寄存器）。这些内容里包含了请求特权级（Requested Privilege Level，简称RPL）字段，用0-3表示。0表示最高特权级，对应内核态，此时它可以访问内核代码，也可以访问用户代码；3表示最低特权级，对应用户态，此时它只能访问用户态代码。cs(代码段寄存器)拥有一个由CPU自己维护的当前特权级字段（Current Privilege Level，简称CPL），这点对我们来说非常重要。**代码段寄存器中的2位宽的CPL字段的值总是等于CPU的当前特权级。**不管CPU内部正在发生什么，只要看一眼cs中的CPL，你就可以知道此刻的特权级了。

![](http://7xizd0.com1.z0.glb.clouddn.com/blog/80386-segment-register.jpg)

### 1.1.3 使用

分段功能自8086提出后，一直被x86处理器所使用着。**每一条会访问内存的指令都隐式的使用了段寄存器。**比如，一条跳转指令会用到代码段寄存器(cs)，一条压栈指令(stack push instruction)会使用到堆栈段寄存器（ss）。

在大部分情况下你可以使用指令明确的改写段寄存器的值。段寄存器存储了一个16位的段选择符（segment selector）,它们可以经由机器指令（比如MOV）被直接加载。唯一的例外是**代码段寄存器（cs），它只能被影响程序执行顺序的指令所改变，比如CALL或JMP指令**。虽然分段功能一直是开启的，但其在实模式与保护模式下的运作方式并不相同的。

### 1.1.4 内存保护

CPU会在两个关键点上保护内存：当一个段选择符被加载时，以及，当通过线形地址访问一个内存页时。因此，保护也反映在内存地址转换的过程之中，既包括分段又包括分页。当一个数据段选择符被加载时，就会发生下述的检测过程：

![](http://7xizd0.com1.z0.glb.clouddn.com/blog/80386-segmentation-protection.jpg)

因为越高的数值代表越低的特权，上图中的MAX()用于挑出CPL和RPL中特权最低的一个，并与描述符特权级（descriptor privilege level，简称DPL）比较。如果DPL的值大于等于它，那么这个访问就获得许可了。RPL背后的设计思想是：允许内核代码加载特权较低的段。但堆栈段寄存器是个例外，它要求CPL，RPL和DPL这3个值必须完全一致，才可以被加载。

事实上，段保护功能几乎没什么用，因为现代的内核使用扁平的地址空间。在那里，用户模式的段可以访问整个线性地址空间。真正有用的内存保护发生在分页单元中，即从线性地址转化为物理地址的时候。一个内存页就是由一个页表项（page table entry）所描述的字节块。页表项包含两个与保护有关的字段：一个超级用户标志（supervisor flag），一个读写标志（read/write flag）。超级用户标志是内核所使用的重要的x86内存保护机制。当它开启时，内存页就不能被ring3访问了。尽管读写标志对于实施特权控制并不像前者那么重要，但它依然十分有用。当一个进程被加载后，那些存储了二进制镜像（即代码）的内存页就被标记为只读了，从而可以捕获一些指针错误，比如程序企图通过此指针来写这些内存页。这个标志还被用于在调用fork创建Unix子进程时，实现写时拷贝功能（copy on write）。

关于CPU特权级切换的详细使用参考：[CPU的运行环、特权级与保护](http://blog.csdn.net/drshenlei/article/details/4265101)

## 1.2 段描述符

一个程序可以分解成多个在逻辑上相对独立的模块。每个模块作为一个单独的段，都以该段的起点进行相对编址。所以我们需要用一个数据结构描述各个段的相关信息，比如该段装进内存的基址（段基址），该段的长度，以及该段是否存在内存中等信息，这个数据结构就是段描述符。这样，每个模块都有一个段描述符，用来描述该段的属性，而段描述符表就是段描述符的集合。

段描述符表的表项就是段描述符，段描述要存储三个信息：基地址、段长度和段属性。用8个字节来存储这三个信息，段基址是32位所以占四个字节，然后用20位来描述段长度，剩下12位就用来存储段的属性信息了。

参考：
http://book.51cto.com/art/201006/208522.htm
http://www.cppblog.com/xingkongyun/articles/62743.html

### 1.2.1 80286

描述符有八字节，在80286中，组内有最高2个字节保留未用，其余6个字节分别存储着程序（或数据）段所占内存的长度（段限长，2个字节）、起始的物理地址（称段基地址，3个字节）和访问权（1个字节）。内存中每段程序（或数据）均可用一个描述符来表示。

### 1.2.2 80386段属性信息

80386的段描述符内容比80286要丰富很多。

G：一位，G=0：表示以字节为单位表示段的长度，刚才我们说了我们用20位存储段的长度，那么这样我们段的最大长度就是2^20次方，即1M大小，即我们给程序分段的时候，一个段最大是1M。G=1:表示以4KB表示段的长度，这样我们一个段的最大长度就是2^20次方乘以4KB，即4GB。后边我们会知道linux内核就让这个G等于1，从而直接越过x86的段机制，使逻辑地址不用映射线性地址，二是直接映射到物理地址(分页机制)。

D:一位，表示操作数的位数，D=1表示32位操作数，D=0表示16位操作数，这显然是为向下兼容而设计的。

接下来两位暂时没用，可留作扩展。

P：一位，表示这个段是否在内存中，如果我们要把这个段加载进内存，那么在加载进去的时候把这个值修改为1，否则让它等于0。

DPL：两位，表示段描述符的特权级。其值从0（最高特权，内核模式）到3（最低特权，用户模式），用于控制对段的访问。

S：一位，表示这个段是系统段还是用户段。S=0，则为系统段，即内核专门使用的段，S=1,表示用户段，即为程序的代码段、数据段或堆栈段。

类型占三位：依次是E、D、W。E=0，为数据段描述符，这时D位表示数据的扩展方向，D=0,表示向地址增大的方向扩展，反之，向地址减小的方向扩展。E=1时，直接表示的是数据段，此时W=0时表示数据段不能写（我们就可以想到C++中定义const变量的时候，存储const变量的段肯定是修改了这个值的），W=1,数据段可写。

保护模式下，有三种类型的描述符表，分别是全局描述符表（GDT），中段描述符表（IDT），局部描述符表（LDT）。为了加快对这些表的访问，Inter设计了三个专门的寄存器，GDTR、IDTR、LDTT，以存放这些表的基地址和表的长度界限。

## 1.3 段描述符表

将不同程序（或数据）段的描述符在内存中连续排列起来，所形成的表称为描述符表。

* 由与全局有关的程序（或数据）段的描述符组织在一块的表称全局描述符表（GDT）。一个系统内只有一张GDT。存放该表的物理地址和长度的寄存器称GDTR。
* 所有中断服务程序的描述符表称中断描述符表（IDT），一个系统也仅有一张IDT，中断描述符表是CPU用来处理中断和程序异常的，中断描述符表中存储的是门描述符。每一个中断都被赋予一个从0到255的编号，叫做中断向量。**处理器把中断向量作为IDT表项的索引**，用来指出当中断发生时使用哪一个门描述符来处理中断。
* 由不涉及全局的程序（或数据）段的描述符所组成的表称局部描述符表（LDT）。

GDT和LDT各占用64KB内存，含8K个描述符。

由于一个段描述符是8字节长，因此它在GDT或LDT内的相对地址是由段选择符的最高13位的值乘以8得到的。

例：如果GDT在0x00020000（这个值保存在gdtr中），且由段选择符所指定的索引号为2，那么相应的段描述符地址是0x00020000 + （2 * 8）= 0x00020010

## 1.4 段描述符高速缓冲寄存器

为了避免在每次存储器访问时，都要访问描述符表而获得对应的段描述符，从80286开始每个段寄存器都配有一个高速缓冲寄存器，称之为**段描述符高速缓冲寄存器**或描述符投影寄存器，对程序员而言它是不可见的，即**每个段寄存器都有一个隐藏部分用于缓存段选择符所对应的那个段描述符**。

段描述符的内容一旦被访问，就会被cache，所以在随后的访问中，就不再需要去实际读取GDT了，否则会有损性能。即，每当把一个选择子装入到某个段寄存器时，处理器从描述符表中取出相应的描述符，把描述符中的信息保存到对应的高速缓冲寄存器中。**此后对该段访问时，处理器都使用对应高速缓冲寄存器中的描述符信息，而不用再从描述符表中取描述符。**
     
段描述符高速缓冲寄存器之内保存的描述符信息将一直保存到重新把选择子装载到段寄存器时再更新。程序员尽管不可见段描述符高速缓冲寄存器，但必须注意到它的存在和它的上述更新时机。例如，在改变了描述符表中的某个当前段的描述符后，也要更新对应的段描述符高速缓冲寄存器的内容，即使段选择子未作改变，这可通过重新装载段寄存器实现。

参考：http://wenku.baidu.com/link?url=-eUpCYmSxHwy3CnJCpgy08_xNZ-gR3j8SswY5_lscN6hSDm6HzjQWZB8HfFJV70QAaJoXlo9m0dHr6AozjwlBiMBVY0L91iR2g48DmqYjGK

# 2 段地址转换

![](http://7xizd0.com1.z0.glb.clouddn.com/blog/IA-32-segmentation-addressing.jpg)

下图更详细一点：

![](http://7xizd0.com1.z0.glb.clouddn.com/blog/IA-32-segmentation-addressing-2.jpg)

流程顺序描述如下：

* 首选确定要访问的段（方式与x86-16相同），然后决定使用的段寄存器。
* 根据段选择符号的TI字段决定是访问GDT还是LDT，他们的首地址则通过GTDR和LDTR来获得。
* 将段选择符的Index字段的值*8，然后加上GDT或LDT的首地址，就能得到当前段描述符的地址。（乘以8是因为段描述符为8字节）
* 得到段描述符的地址后，可以通过段描述符中BASE获得段的首地址。
* 将逻辑地址中32位的偏移地址和段首地址相加就可以得到实际要访问的物理地址。

# 3 linux的使用

与其说linux是如何利用X86中的分段机制，还不如说是如何绕过linux分段机制。

linux是一个可移植的操作系统，它支持x86，Alpha，arm等多种体系结构。但是Alpha，arm很多体系结构其实是不支持分段机制的，但是他们都支持分页机制。linux为了能移植到x86上，做了不少工作。

首先要在x86上运行程序，那不可避免要用到段机制，因为X86的分段机制不可关闭。80386的段描述符中有一个表示以字节为单位还是以4KB为单位表示一个段长度的属性位。以4KB为单位，那么一个段最大长度能到4GB。根据这一点，我们把一个段的段基址固定设置为0，然后让G=1，于是我们一个段的最大长度就是4GB了，这个就能和我们4GB的线性地址空间一一映射了。通过这样的处理，就跳过了x86的段机制，逻辑地址和线性地址可以混为一谈了。

但是x86分段的好处还是要用起来的，比如必须为代码段和数据段创建不同的段，这样linux为代码段和数据段分别创建了一个基地址为0，段长度为4GB的段描述符。不仅如此，由于linux内核运行在特权级0，用户程序运行在特权级3，x86规定说特权级为3的用户程序是不能访问特权级为0的内核代码的，所以linux又分别为内核和用户程序分别创建代码段和数据段。

于是在arch/x86/include/asm/segment.h中这样定义四个段（即在机器启动过程中段寄存器中放的值）：

```c
#define __KERNEL_CS     (GDT_ENTRY_KERNEL_CS*8)  
#define __KERNEL_DS     (GDT_ENTRY_KERNEL_DS*8)  
#define __USER_DS       (GDT_ENTRY_DEFAULT_USER_DS*8+3)  
#define __USER_CS       (GDT_ENTRY_DEFAULT_USER_CS*8+3)
```

其中：

```c
#define GDT_ENTRY_DEFAULT_USER_CS       14  
#define GDT_ENTRY_DEFAULT_USER_DS       15  
#define GDT_ENTRY_KERNEL_BASE           (12)  
#define GDT_ENTRY_KERNEL_CS             (GDT_ENTRY_KERNEL_BASE+0)  
#define GDT_ENTRY_KERNEL_DS             (GDT_ENTRY_KERNEL_BASE+1)  
```

于是上边的定义的结果是下边这样：

```c
#define __KERNEL_CS     0x00C0      /*内核代码段，index=12，TI=0,RPL=0*/  
#define __KERNEL_DS     0x00D0      /*内核数据段，index=13，TI=0,RPL=0*/  
#define __USER_DS       0x00E3      /*用户数据段，index=14，TI=0,RPL=3*/  
#define __USER_CS       0x00F3      /*用户代码段，index=15，TI=0,RPL=3*/  
```

于是我们可以用12,13,14,15四个索引来找到我们四个段所对应的段描述符，并且我们把内核代码段的特权声明为0，用户代码段的特权为3，TI为0表示我们总是访问全局描述符表。

在我们对应的段描述符中我们把G设置为1，段上限规定为0xfffff，就巧妙的绕过了x86的分段机制。

来看看Linux 用户模式应用程序的一个跳转指令：

![](http://7xizd0.com1.z0.glb.clouddn.com/blog/x86-segmentation-in-linux.jpg)

但在这里我不能忽略的一个问题就是，我们把四个段的上限全部设置为4G，那就完全破坏了段的保护，就是说，我们有可能随随便便就修改了我们的其他段的数据。

但是现在还是个线性地址，我们还是有处理这个问题的办法，这就是80386中同时引入的分页机制，即在线性地址与物理地址之间来一层映射。


# 4 参考：
http://blog.csdn.net/bcs_01/article/category/1409609
http://www.ahlinux.com/start/kernel/6876.html